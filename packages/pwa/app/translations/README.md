# Localization

Most of the files in this folder are generated by `react-intl` **CLI tool**:
- `pwa/app/translations/en.json` <- output of _extracting_ the default messages, which you can send to your translators
- `pwa/app/translations/[locale].json` <- the files that your translators make for the other locales
- `pwa/app/translations/compiled/[locale].json` <- output of _compiling_ the messages into AST format
  - Compiling helps improve the performance because it allows `react-intl` to skip the parsing step

Several **npm scripts** are available to you that make it easier to use the CLI tool. See `pwa/package.json` for more details.

- To **extract the default messages** in your app, run `npm run extract-messages` to have all of the default English messages extracted into their own JSON file.
- To **compile the messages** from all of the locales, run `npm run compile-messages`.

### Supported Locales and Default Locale

The supported locales, default locale and currency settings are defined in `pwa/package.json` in an object called `l10n`.

The strings in `l10n.supportedLocales[n].id` and `l10n.defaultLocale` follow the format supported by OCAPI and Commerce API: `<language code>-<country code>` as defined in this InfoCenter topic: [OCAPI localization 21.8](https://documentation.b2c.commercecloud.salesforce.com/DOC1/topic/com.demandware.dochelp/OCAPI/current/usage/Localization.html).

The currency code in `l10n.supportedCurrencies` and `l10n.supportedLocales[n].preferredCurrency` follow the ISO 4217 standard.

**Important**: The supported locales and default locale settings in `pwa/package.json` must match the locale settings for your B2C Commerce instance. For more information about configuring locales on a B2C Commerce instance, see this InfoCenter topic: [Configure Site Locales](https://documentation.b2c.commercecloud.salesforce.com/DOC2/topic/com.demandware.dochelp/content/b2c_commerce/topics/admin/b2c_configuring_site_locales.html).

Here’s the default locale configuration in `pwa/package.json`:

```
"l10n": {
    "supportedCurrencies": [
        "GBP",
        "EUR",
        "CNY",
        "JPY"
    ],
    "defaultCurrency": "GBP",
    "supportedLocales": [
        {
            "id": "en-GB",
            "preferredCurrency": "GBP"
        },
        {
            "id": "fr-FR",
            "preferredCurrency": "EUR"
        },
        {
            "id": "it-IT",
            "preferredCurrency": "EUR"
        },
        {
            "id": "zh-CN",
            "preferredCurrency": "CNY"
        },
        {
            "id": "ja-JP",
            "preferredCurrency": "JPY"
        }
    ],
    "defaultLocale": "en-GB"
}
```

### Formatting Messages

To support localization for multiple locales, write messages...

-   _inline_ in the components, so it’s easier to see where in the page or component that they get used in
-   and in the **default locale** (for example, in English)

For example, in your React component, you can add formatted messages like `intl.formatMessage({defaultMessage: '...'})` or `<FormattedMessage defaultMessage="..." />`

At the minimum, only defaultMessage is the required parameter. The message id is optional. If you don’t specify it, the id is auto-generated for you.

### Workflow Between Developers and Translation Team

During your development, you extract and compile the messages and pass the generated JSON files to the translation team, as well as using the translated files in the app.

We’ve provided a few npm scripts to help you:

-   `npm run extract-messages` to extract the default messages
    -   so you don’t have to create the JSON file yourself by hand
-   `npm run compile-messages` to compile all locales into Abstract Syntax Tree (AST) format
    -   `react-intl` can use this AST format to bypass the parsing step and thus, save a bit of time.

Whenever you do a build, the extract and compile scripts are run automatically in case you forgot to extract the latest messages.

### Testing with a Pseudo Locale

To check whether you’ve wrapped all of the hardcoded strings with either `intl.formatMessage()` or `<FormattedMessage />` , there’s a quick way to test that by running `npm run start:pseudolocale`. It runs your local dev server with the locale forced to the pseudo locale.

Loading the site in your browser, you can quickly see that those messages that have been formatted have a long `SSS` appended to them.

### Tips

Here are a few useful things to know for developers.

#### User-Preferred Locales vs. App-Supported Locales

How a locale gets chosen depends on whether there’s a match found between 2 sets of locales. On a high level, it looks like this:

1. Get the app-supported locales, which are defined in `package.json` (under `l10n.supportedLocales`).
2. Get the user-preferred locales, which are what the visitors prefer to see. The developer is responsible for fully implementing them in their own projects within the special `_app` component.
3. If there’s a match between these 2 sets of locales, then the app would use it as the target locale.
4. Otherwise, the app would fall back to its default locale (which is also defined in `package.json` under `l10n.defaultLocale` ).

#### How to Detect the Active Locale

-   Within component render, `useIntl` hook is available to you: `const {locale} = useIntl()`
-   Within a page’s `getProps` there’s a `params` prop (specifically `params.locale`) coming from the routes that can tell you about which locale is being used in the current page URL.

#### Dynamic Loading of the Translation Files

Using dynamic import, regardless of how many locales the app supports, it would load only one locale at a time.

Initially, on app load, the translated messages are part of the server-rendered html. Afterwards on the client side, when dynamically changing the locale, the app would download the JSON file associated with that locale.

-   Each locale is a separate JSON file in the bundle. And it’s served with a 1-year cache header.
-   When a new bundle is deployed, you must download the JSON files again.

#### Link Component

The generated project comes with its own `Link` component. It automatically inserts the locale in the URLs for you.
